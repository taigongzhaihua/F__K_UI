# FK UI 框架实现路线

## 阶段 0：准备工作
- 梳理当前代码，将已有 `Event`, `Application`, `Window` 等迁移到新目录结构（已完成）。
- 建立单元测试/示例工程基础，确保可以快速编译运行。
- 准备编译环境：C++23、CMake、glad/GLFW/FreeType 依赖已在 third_party 中集成。

## 阶段 1：核心模块 (fk::core)
1. **事件系统完善**
   - 补充单元测试覆盖连接、断开、复制/移动语义。
   - 明确异常安全策略，决定 handler 抛异常时的传播方式。
2. **Dispatcher 与定时器**
   - 设计 `Dispatcher` API（Post/Send/Run/Shutdown）。
   - 基于 GLFW 事件循环实现主线程 Dispatcher；封装线程检查。
   - 实现 `Timer`、`DispatcherOperation`；编写测试验证。
3. **日志与基础工具**
   - 提供轻量 Logger 接口，默认输出到标准输出。
   - 定义 `Result<T,E>` 或使用 `std::expected` (C++23) 代表错误返回。

## 阶段 2：绑定模块 (fk::binding)
1. **依赖属性基础**
   - 实现 `DependencyProperty` 注册/查找，`PropertyStore` 持有值优先级。
   - 支持 `GetValue`/`SetValue`/`ClearValue`，触发 `PropertyChanged`。
2. **绑定表达式骨架**
   - 设计 `Binding`, `BindingExpression`，实现 OneWay 模式。
   - 引入 `BindingPath` + `PropertyAccessor` 注册机制。
3. **扩展功能**
   - TwoWay 绑定（目标更新源）。
   - Converter、UpdateSourceTrigger、验证器（可在阶段 4 推迟）。

## 阶段 3：UI 基础 (fk::ui)
1. **对象体系搭建**
   - 实现 `DispatcherObject`、`DependencyObject`、`UIElement`、`FrameworkElement`。
   - 处理逻辑树/视觉树挂接，定义生命周期事件。
2. **布局系统**
   - 建立 Measure/Arrange 框架，提供 `Size`, `Rect`, `Thickness` 等基础结构。
   - 实现 `Panel` 抽象及 `StackPanel`、`Canvas` 作为首批面板。
3. **基础控件**
   - `ContentControl`、`ButtonBase`、`TextBlock` 等简单控件。
   - 提供链式 API (`Width`, `Height`, `Margin`, `Content`, `Text` 等)。
4. **事件与命令**
   - 路由事件体系（Direct/Bubble/Tunnel）。
   - `ICommand`, `CommandBinding`, 控件触发命令。

## 阶段 4：渲染管线 (fk::render)
1. **渲染抽象**
   - 定义 `IRenderer`、`RenderCommand`, `RenderList`, `RenderTreeBuilder`。
   - 搭建 `RenderHost`，整合到 `Window`。
2. **OpenGL 实现**
   - 初始化 glad/GLFW 上下文、SwapBuffers。
   - 实现基础绘制：矩形填充、简单文本输出（FreeType + GlyphAtlas）。
3. **优化与调试工具**
   - 状态缓存、批处理、性能统计。
   - 简单调试界面（打印命令列表、绘制脏矩形）。

## 阶段 5：应用层 (fk::app)
1. **Application 重构**
   - 使用新的 Dispatcher/RenderHost 管理窗口。
   - 完成生命周期事件与异常处理。
2. **Window 管理器**
   - 统一窗口创建/销毁流程。
   - 支持多窗口、窗口切换、退出条件。
3. **示例应用迁移**
   - 使用新 API 重写 `examples/main.cpp`，验证全链路运行。

## 阶段 6：主题与资源 (fk::theme)
1. **ResourceDictionary 与 ThemeManager**
   - 实现链式资源注册，支持静态/动态资源。
   - 接入 `FrameworkElement::Resources()` 与 `Application::Resources()`。
2. **Style/Setter/Triggers**
   - 定义样式对象，应用到控件依赖属性。
   - 实现主题切换事件，确保 `DynamicResource` 自动刷新。
3. **主题示例**
   - 编写代码定义 Light/Dark 主题，演示运行时切换。

## 阶段 7：拓展特性
- **高级控件**：ListBox、TreeView、ScrollViewer、TabControl 等。
- **动画系统**：StoryBoard、视觉状态、过渡动画。
- **输入增强**：触摸/手柄支持、手势识别。
- **国际化**：字体 fallback、文本测量优化。
- **资源管线**：可选静态资源编译或热更新工具链。

## 阶段 8：工程保障
- **测试体系**：引入 Catch2/GoogleTest，覆盖核心模块。
- **CI/CD**：配置 GitHub Actions 或其他 CI，执行构建与测试。
- **文档与示例**：完善 API 文档、开发指南、示例库。

## 里程碑规划
| 阶段 | 目标 | 可交付项 |
|------|------|-----------|
| Phase 1 | core 完成 | Dispatcher/Timer/Logger 测试通过 |
| Phase 2 | 绑定骨架 | 示例：属性绑定更新 |
| Phase 3 | UI 骨干 | 可以创建基础控件并排版 |
| Phase 4 | 渲染闭环 | 窗口显示控件、文本渲染 |
| Phase 5 | 应用运行 | 示例应用可交互关闭 |
| Phase 6 | 主题系统 | Dark/Light 切换示例 |
| Phase 7+ | 功能拓展 | 控件库、动画、资源工具 |

## 协作建议
- 每个阶段完成后合并主分支，保持可构建状态。
- 阶段之间可以并行准备测试、文档。
- 明确公共 API 版本，避免模块间频繁破坏性修改。

---
> 路线可根据实际进度调整，推荐保持“核心先行、渐进迭代”的节奏，确保每个阶段结束时都能运行一个最小可验证示例。