# 哈希表缓存 + NameScope 混合优化方案

## 概述

结合哈希表缓存和NameScope类，可以获得两种方案的优点，实现最佳性能和最佳设计。

## 为什么要结合？

### 哈希表缓存的优点
- ✅ O(1) 查找时间
- ✅ 实现相对简单
- ✅ 可选启用

### NameScope类的优点
- ✅ 更清晰的设计（显式作用域）
- ✅ 自动维护名称索引
- ✅ 可以检测重复名称
- ✅ 符合WPF设计模式

### 结合的优势
- ✅ **最佳性能**：O(1)查找
- ✅ **清晰设计**：显式的作用域管理
- ✅ **自动化**：名称变更时自动更新索引
- ✅ **可维护性**：代码结构更清晰
- ✅ **兼容性**：与WPF概念一致

## 混合方案设计

### 架构设计

```
┌─────────────────────────────────────────┐
│          UIElement / Window             │
│  ┌───────────────────────────────────┐  │
│  │        NameScope (可选)            │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │  HashMap<name, element*>    │  │  │
│  │  │  - RegisterName()           │  │  │
│  │  │  - UnregisterName()         │  │  │
│  │  │  - FindName() -> O(1)       │  │  │
│  │  └─────────────────────────────┘  │  │
│  └───────────────────────────────────┘  │
│                                         │
│  FindName() {                           │
│    if (nameScope_) {                    │
│      return nameScope_->FindName();     │
│    }                                    │
│    return FindNameSlow();  // 回退     │
│  }                                      │
└─────────────────────────────────────────┘
```

### 实现代码

#### 1. NameScope 类（核心）

```cpp
// NameScope.h
#pragma once
#include <unordered_map>
#include <string>

namespace fk::ui {

class DependencyObject;

/**
 * 命名作用域 - 管理元素名称到元素的映射
 * 提供 O(1) 的名称查找性能
 */
class NameScope {
private:
    // 哈希表：名称 -> 元素
    std::unordered_map<std::string, DependencyObject*> names_;
    
    // 是否允许重复名称（调试用）
    bool allowDuplicates_{true};
    
public:
    /**
     * 注册名称
     * @param name 元素名称
     * @param obj 元素对象
     * @return 是否成功（如果已存在且不允许重复则失败）
     */
    bool RegisterName(const std::string& name, DependencyObject* obj) {
        if (name.empty() || !obj) {
            return false;
        }
        
        auto it = names_.find(name);
        if (it != names_.end()) {
            if (!allowDuplicates_ && it->second != obj) {
                // 重复名称，且不是同一个对象
                std::cerr << "Warning: Duplicate name '" << name 
                          << "' in NameScope" << std::endl;
                return false;
            }
            // 允许重复或更新同一对象
        }
        
        names_[name] = obj;
        return true;
    }
    
    /**
     * 注销名称
     * @param name 要注销的名称
     */
    void UnregisterName(const std::string& name) {
        if (!name.empty()) {
            names_.erase(name);
        }
    }
    
    /**
     * 查找名称 - O(1)
     * @param name 要查找的名称
     * @return 找到的元素，未找到返回 nullptr
     */
    DependencyObject* FindName(const std::string& name) const {
        if (name.empty()) {
            return nullptr;
        }
        
        auto it = names_.find(name);
        return (it != names_.end()) ? it->second : nullptr;
    }
    
    /**
     * 更新名称（元素重命名时调用）
     * @param oldName 旧名称
     * @param newName 新名称
     * @param obj 元素对象
     */
    void UpdateName(const std::string& oldName, 
                   const std::string& newName, 
                   DependencyObject* obj) {
        if (!oldName.empty() && oldName != newName) {
            UnregisterName(oldName);
        }
        if (!newName.empty()) {
            RegisterName(newName, obj);
        }
    }
    
    /**
     * 清空所有名称
     */
    void Clear() {
        names_.clear();
    }
    
    /**
     * 获取名称数量
     */
    size_t GetNameCount() const {
        return names_.size();
    }
    
    /**
     * 设置是否允许重复名称
     */
    void SetAllowDuplicates(bool allow) {
        allowDuplicates_ = allow;
    }
    
    /**
     * 检查名称是否已注册
     */
    bool HasName(const std::string& name) const {
        return !name.empty() && names_.find(name) != names_.end();
    }
};

} // namespace fk::ui
```

#### 2. UIElement 集成

```cpp
// UIElement.h
class UIElement : public Visual {
private:
    // 命名作用域（可选，按需创建）
    std::unique_ptr<NameScope> nameScope_;
    
public:
    /**
     * 创建命名作用域
     * 调用此方法后，该元素及其子树中的所有命名元素
     * 都会自动注册到这个作用域中，实现 O(1) 查找
     */
    void CreateNameScope() {
        if (!nameScope_) {
            nameScope_ = std::make_unique<NameScope>();
            // 收集所有子元素的名称
            RegisterChildrenNames();
        }
    }
    
    /**
     * 获取命名作用域（如果存在）
     */
    NameScope* GetNameScope() const {
        return nameScope_.get();
    }
    
    /**
     * 检查是否有命名作用域
     */
    bool HasNameScope() const {
        return nameScope_ != nullptr;
    }
    
    /**
     * 设置元素名称（重写）
     * 自动更新命名作用域
     */
    void SetName(const std::string& name) override {
        std::string oldName = GetElementName();
        SetElementName(name);
        
        // 更新命名作用域
        NameScope* scope = FindNearestNameScope();
        if (scope) {
            scope->UpdateName(oldName, name, this);
        }
    }
    
    /**
     * 优化的查找方法
     * 如果有命名作用域，使用 O(1) 查找
     * 否则回退到标准的 O(n) 查找
     */
    UIElement* FindName(const std::string& name) override {
        // 优先使用命名作用域
        NameScope* scope = FindNearestNameScope();
        if (scope) {
            auto* found = scope->FindName(name);
            if (found) {
                return dynamic_cast<UIElement*>(found);
            }
            return nullptr;
        }
        
        // 回退到标准查找
        return FindNameSlow(name);
    }
    
private:
    /**
     * 查找最近的命名作用域
     * 从当前元素开始向上遍历，找到第一个有命名作用域的祖先
     */
    NameScope* FindNearestNameScope() {
        UIElement* current = this;
        while (current) {
            if (current->nameScope_) {
                return current->nameScope_.get();
            }
            current = dynamic_cast<UIElement*>(current->GetLogicalParent());
        }
        return nullptr;
    }
    
    /**
     * 注册所有子元素的名称到命名作用域
     */
    void RegisterChildrenNames() {
        if (!nameScope_) return;
        
        // 注册自己
        if (!GetElementName().empty()) {
            nameScope_->RegisterName(GetElementName(), this);
        }
        
        // 递归注册子元素
        for (UIElement* child : GetLogicalChildren()) {
            if (child) {
                child->RegisterToScope(nameScope_.get());
            }
        }
    }
    
    /**
     * 将元素注册到指定作用域
     */
    void RegisterToScope(NameScope* scope) {
        if (!scope) return;
        
        // 注册自己
        if (!GetElementName().empty()) {
            scope->RegisterName(GetElementName(), this);
        }
        
        // 递归注册子元素（如果它们没有自己的作用域）
        if (!nameScope_) {
            for (UIElement* child : GetLogicalChildren()) {
                if (child) {
                    child->RegisterToScope(scope);
                }
            }
        }
    }
    
    /**
     * 标准的 O(n) 查找（回退方法）
     */
    UIElement* FindNameSlow(const std::string& name) {
        if (name.empty()) return nullptr;
        
        if (GetElementName() == name) {
            return this;
        }
        
        for (UIElement* child : GetLogicalChildren()) {
            if (child) {
                UIElement* found = child->FindName(name);
                if (found) return found;
            }
        }
        
        return nullptr;
    }
};
```

#### 3. Window 类集成

```cpp
// Window.h
class Window : public ContentControl {
public:
    Window() {
        // 窗口默认创建命名作用域
        CreateNameScope();
    }
    
    /**
     * 在窗口中查找元素 - O(1)
     */
    UIElement* FindName(const std::string& name) {
        // 使用窗口的命名作用域
        if (auto* scope = GetNameScope()) {
            auto* found = scope->FindName(name);
            return dynamic_cast<UIElement*>(found);
        }
        
        // 回退到标准查找
        auto* content = GetContent();
        if (content) {
            return content->FindName(name);
        }
        return nullptr;
    }
};
```

## 使用示例

### 示例1：基本使用

```cpp
// 创建窗口（自动有命名作用域）
auto window = app->CreateWindow();

// 创建UI元素
auto* panel = new StackPanel();

auto* button = new Button();
button->Name("submitButton");  // 自动注册到窗口的命名作用域
button->Content("提交");
panel->AddChild(button);

auto* text = new TextBlock();
text->Name("statusText");  // 自动注册
text->Text("就绪");
panel->AddChild(text);

window->Content(panel);

// O(1) 查找！
auto* found = window->FindName("submitButton");
if (auto* btn = dynamic_cast<Button*>(found)) {
    btn->Content("已找到");
}
```

### 示例2：嵌套命名作用域

```cpp
auto window = app->CreateWindow();

// 主面板使用窗口的命名作用域
auto* mainPanel = new StackPanel();

// Header 区域（创建自己的命名作用域）
auto* headerPanel = new StackPanel();
headerPanel->CreateNameScope();  // 独立作用域
headerPanel->Name("headerPanel");

auto* headerButton = new Button();
headerButton->Name("actionButton");  // 注册到 headerPanel 的作用域
headerPanel->AddChild(headerButton);

mainPanel->AddChild(headerPanel);

// Content 区域（创建自己的命名作用域）
auto* contentPanel = new StackPanel();
contentPanel->CreateNameScope();  // 独立作用域
contentPanel->Name("contentPanel");

auto* contentButton = new Button();
contentButton->Name("actionButton");  // 相同名称，但在不同作用域 ✅
contentPanel->AddChild(contentButton);

mainPanel->AddChild(contentPanel);

window->Content(mainPanel);

// O(1) 查找不同作用域中的元素
auto* header = window->FindName("headerPanel");
if (auto* hp = dynamic_cast<StackPanel*>(header)) {
    auto* btn = hp->FindName("actionButton");  // header的按钮
}

auto* content = window->FindName("contentPanel");
if (auto* cp = dynamic_cast<StackPanel*>(content)) {
    auto* btn = cp->FindName("actionButton");  // content的按钮
}
```

### 示例3：动态添加元素

```cpp
auto window = app->CreateWindow();
auto* panel = new StackPanel();
window->Content(panel);

// 动态添加元素 - 自动注册
for (int i = 0; i < 100; i++) {
    auto* button = new Button();
    button->Name("button_" + std::to_string(i));
    button->Content("Button " + std::to_string(i));
    panel->AddChild(button);
    // 自动注册到窗口的命名作用域
}

// O(1) 查找任意按钮
auto* btn50 = window->FindName("button_50");  // 快！
```

### 示例4：ElementName绑定（自动受益）

```cpp
auto window = app->CreateWindow();
auto* panel = new StackPanel();

auto* slider = new Slider();
slider->Name("volumeSlider");
slider->Value(50);
panel->AddChild(slider);

auto* text = new TextBlock();
Binding binding;
binding.ElementName("volumeSlider").Path("Value");
text->SetBinding(TextBlock::TextProperty(), std::move(binding));
panel->AddChild(text);

window->Content(panel);

// ElementName 绑定解析时，也是 O(1) 查找！
// 因为它会使用命名作用域
```

## 性能对比

| 场景 | 无优化 | 仅哈希表缓存 | 仅NameScope | 混合方案 |
|------|--------|--------------|-------------|----------|
| 首次查找 | O(n) | O(n) | O(1) | O(1) |
| 后续查找 | O(n) | O(1) | O(1) | O(1) |
| 添加元素 | O(1) | O(1)* | O(1) | O(1) |
| 删除元素 | O(1) | O(1)* | O(1) | O(1) |
| 重命名元素 | O(1) | O(1)* | O(1) | O(1) |
| 内存开销 | 最小 | O(n) | O(n) | O(n) |
| 代码复杂度 | 简单 | 中等 | 中等 | 中等 |
| 设计清晰度 | 一般 | 一般 | 好 | 最好 |

*需要重建缓存

## 优势总结

### 1. 性能优势
- ✅ **O(1) 查找**：所有查找都是常数时间
- ✅ **O(1) 注册**：添加元素时自动注册
- ✅ **O(1) 更新**：重命名时直接更新哈希表

### 2. 设计优势
- ✅ **显式作用域**：通过 CreateNameScope() 明确作用域边界
- ✅ **自动管理**：名称变更时自动更新索引
- ✅ **重复检测**：可选的重复名称检测
- ✅ **WPF兼容**：与WPF的NameScope概念一致

### 3. 灵活性
- ✅ **可选功能**：默认不创建（节省内存）
- ✅ **按需启用**：只为需要的容器创建
- ✅ **嵌套作用域**：支持多层作用域
- ✅ **回退机制**：没有作用域时自动回退到标准查找

### 4. 可维护性
- ✅ **代码清晰**：职责分离，NameScope专门管理名称
- ✅ **易于调试**：可以查看作用域中的所有名称
- ✅ **易于扩展**：可以添加更多功能（如名称验证）

## 实现策略

### 阶段1：基础实现
1. 实现 NameScope 类
2. 在 Window 中默认创建 NameScope
3. 修改 UIElement::SetName() 自动注册

### 阶段2：完善功能
1. 支持嵌套命名作用域
2. 添加重复名称检测（可选）
3. 实现作用域边界管理

### 阶段3：优化和测试
1. 性能基准测试
2. 内存使用优化
3. 边界情况处理

## 使用建议

### 何时使用混合方案

**推荐使用**：
- ✅ 大型应用（> 500 元素）
- ✅ 频繁查找场景
- ✅ 需要清晰的作用域管理
- ✅ 希望与WPF保持一致

**可以不用**：
- ✅ 小型应用（< 100 元素）
- ✅ 很少使用 FindName
- ✅ 内存受限的环境

### 配置建议

```cpp
// 默认配置：窗口有作用域
auto window = app->CreateWindow();  // 自动创建 NameScope

// 为特定容器创建作用域
auto* dialog = new StackPanel();
dialog->CreateNameScope();  // 独立作用域

// 不创建作用域（使用父级或回退到标准查找）
auto* simplePanel = new StackPanel();
// 不调用 CreateNameScope()
```

## 与单独方案的对比

### vs 仅哈希表缓存
- ✅ 更好的设计（显式作用域）
- ✅ 自动维护（不需要手动重建缓存）
- ✅ 支持嵌套作用域
- ⚠️ 略微复杂一些（但更清晰）

### vs 仅NameScope
- ✅ 同样的性能
- ✅ 同样的设计清晰度
- ✅ 同样支持嵌套作用域
- ✅ 哈希表是NameScope的核心实现

**结论**：混合方案实际上就是**正确实现的NameScope**！

## 总结

### 关键点

1. **哈希表是实现手段**，NameScope是设计概念
2. **混合方案 = 正确的NameScope实现**
3. NameScope内部使用哈希表提供O(1)性能
4. 这是**最佳方案**：性能好、设计清晰、易维护

### 推荐

**强烈推荐混合方案**，原因：
- ✅ 最佳性能（O(1)）
- ✅ 最清晰的设计
- ✅ 与WPF完全一致
- ✅ 易于理解和维护
- ✅ 灵活且可扩展

### 实施路线

1. **第一步**：实现NameScope类（包含哈希表）
2. **第二步**：在Window中默认启用
3. **第三步**：支持嵌套作用域
4. **第四步**：完善和优化

这样既获得了哈希表的性能，又获得了NameScope的设计清晰度！

---

**最后更新**：2025年11月16日  
**版本**：1.0
