# 鼠标事件下传验证说明

## 修复内容

### 问题 1：InputManager 根节点设置不正确
**原有实现**：
```cpp
// 在 Window::Show() 中只设置一次，设置为内容元素
if (auto* content = GetContent()) {
    inputManager_->SetRoot(dynamic_cast<Visual*>(content));
}
```

**问题**：
- 只在 Show() 时设置一次，如果后续修改内容则无效
- 设置为内容元素，无法处理窗口本身的事件
- 如果 Show() 时内容尚未设置，InputManager 没有根节点

**修复**：
```cpp
// 在 Window 构造函数中设置，根节点为 Window 本身
inputManager_ = std::make_unique<InputManager>();
inputManager_->SetRoot(this);  // Window 继承自 Visual
```

### 问题 2：HitTest 坐标转换不正确
**原有实现**：
```cpp
// 直接使用父元素的 localPoint，没有减去子元素偏移
Point childLocalPoint = localPoint;
```

**问题**：
- 没有考虑子元素在父元素中的布局位置 (layoutRect_.x, layoutRect_.y)
- 导致所有子元素的命中测试都使用错误的坐标

**修复**：
```cpp
// 获取子元素的布局矩形
Rect childLayoutRect = childElement->GetLayoutRect();

// 转换坐标：减去子元素在父元素中的偏移量
Point childLocalPoint(localPoint.x - childLayoutRect.x, 
                     localPoint.y - childLayoutRect.y);
```

## 鼠标事件流程

### 1. GLFW 事件捕获
```cpp
glfwSetMouseButtonCallback(window, callback);
glfwSetCursorPosCallback(window, callback);
glfwSetScrollCallback(window, callback);
```

### 2. 转换为 PlatformPointerEvent
```cpp
PlatformPointerEvent event;
event.position = Point(xpos, ypos);  // GLFW 窗口坐标
event.type = PlatformPointerEvent::Type::Down/Up/Move;
```

### 3. InputManager 处理
```cpp
void ProcessPointerEvent(const PlatformPointerEvent& event) {
    // 1. 检查指针捕获
    UIElement* target = GetPointerCapture(event.pointerId);
    
    // 2. 如果没有捕获，执行命中测试
    if (!target) {
        target = HitTest(event.position);
    }
    
    // 3. 分发事件到目标元素
    DispatchPointerDown/Up/Move(target, event);
}
```

### 4. HitTest 递归查找
```cpp
UIElement* HitTestRecursive(Visual* visual, const Point& localPoint) {
    // 1. 检查当前元素边界
    if (!bounds.Contains(localPoint)) return nullptr;
    
    // 2. 递归检查子元素（从后向前）
    for (子元素) {
        // 转换坐标到子元素局部空间
        Point childLocalPoint(localPoint.x - child.x, localPoint.y - child.y);
        
        // 递归测试
        UIElement* hitChild = HitTestRecursive(child, childLocalPoint);
        if (hitChild) return hitChild;
    }
    
    // 3. 返回当前元素
    return element;
}
```

### 5. 事件分发到 UIElement
```cpp
void DispatchPointerDown(UIElement* target, event) {
    target->OnPointerPressed(args);
}
```

### 6. Button 处理事件
```cpp
void Button::OnPointerPressed(PointerEventArgs& e) {
    isPressed_ = true;
    e.handled = true;
}

void Button::OnPointerReleased(PointerEventArgs& e) {
    if (isPressed_) {
        Click();  // 触发 Click 事件
    }
}
```

## 坐标系统说明

### GLFW 窗口坐标
- 原点在窗口左上角
- X 轴向右，Y 轴向下
- 单位：像素

### UIElement 局部坐标
- 原点在元素左上角
- X 轴向右，Y 轴向下
- 单位：与窗口相同（像素）

### 坐标转换链
```
GLFW 窗口坐标 (xpos, ypos)
    ↓ (无需转换，Window 的局部坐标系与窗口坐标系对齐)
Window 局部坐标 (xpos, ypos)
    ↓ (减去子元素的 layoutRect.x 和 layoutRect.y)
子元素局部坐标 (xpos - layoutRect.x, ypos - layoutRect.y)
    ↓ (继续递归)
孙元素局部坐标
```

## 验证方法

### 1. 单按钮测试
创建一个窗口，添加一个按钮，点击按钮应该触发 Click 事件。

### 2. 嵌套布局测试
创建 Window -> StackPanel -> Button 的层次结构，点击按钮应该正确命中。

### 3. 多按钮测试
创建多个按钮，点击每个按钮应该只触发对应的 Click 事件。

### 4. 边界测试
点击按钮边界外应该不触发事件，点击按钮边界内应该触发事件。

## 预期结果

所有测试都应该通过，鼠标事件能够正确下传到目标元素并触发相应的处理逻辑。

## 技术保证

1. ✅ InputManager 的根节点正确设置为 Window
2. ✅ HitTest 正确处理坐标转换（考虑子元素布局位置）
3. ✅ GLFW 回调正确设置（按钮、移动、滚轮）
4. ✅ 事件分发链完整（GLFW -> InputManager -> UIElement -> Button）
5. ✅ Button 的 Click 事件正确触发
